# table K1 - Luminance quantize Matrix  
import numpy as np
from functools import partial
from bin_utils import bit_array_to_int

# quantization table for luminance
K0 = np.zeros((8, 8))
K0[0] = [ 16,  11,  10,  16,  24,  40,  51,  61]
K0[1] = [ 12,  12,  14,  19,  26,  58,  60,  55]
K0[2] = [ 14,  13,  16,  24,  40,  57,  69,  56]
K0[3] = [ 14,  17,  22,  29,  51,  87,  80,  62]
K0[4] = [ 18,  22,  37,  56,  68, 109, 103,  77]
K0[5] = [ 24,  35,  55,  64,  81, 104, 113,  92]
K0[6] = [ 49,  64,  78,  87, 103, 121, 120, 101]
K0[7] = [ 72,  92,  95,  98, 112, 100, 103,  99]

# quant Table for chrominance
K1 = np.zeros((8, 8))
K1[0] = [ 17,  28,  24,  47,  99,  99,  99,  99]
K1[1] = [ 18,  21,  26,  99,  99,  99,  99,  99]
K1[2] = [ 24,  26,  26,  99,  99,  99,  99,  99]
K1[3] = [ 47,  66,  99,  99,  99,  99,  99,  99]
K1[4] = [ 99,  99,  99,  99,  99,  99,  99,  99]
K1[5] = [ 99,  99,  99,  99,  99,  99,  99,  99]
K1[6] = [ 99,  99,  99,  99,  99,  99,  99,  99]
K1[7] = [ 99,  99,  99,  99,  99,  99,  99,  99]

# Table K3 
# Table for luminance DC coefficient differences
K3 = dict()
K3[0] = [0,0]
K3[1] = [0,1,0]
K3[2] = [0,1,1]
K3[3] = [1,0,0]
K3[4] = [1,0,1]
K3[5] = [1,1,0]
K3[6]  = [1,1,1,0]
K3[7]  = [1,1,1,1,0]
K3[8]  = [1,1,1,1,1,0]
K3[9]  = [1,1,1,1,1,1,0]
K3[10] = [1,1,1,1,1,1,1,0]
K3[11] = [1,1,1,1,1,1,1,1,0]

# Table K5 
# Table for luminance AC coefficients
K5 = dict()
K5[(0, 0)] = "1010"
K5[(0, 1)] = "00"
K5[(0, 2)] = "01"
K5[(0, 3)] = "100"
K5[(0, 4)] = "1011"
K5[(0, 5)] = "11010"
K5[(0, 6)] = "1111000"
K5[(0, 7)] = "11111000"
K5[(0, 8)] = "1111110110"
K5[(0, 9)] = "1111111110000010"
K5[(0,10)] = "1111111110000011"

K5[(1, 1)] = "1100"
K5[(1, 2)] = "11011"
K5[(1, 3)] = "1111001"
K5[(1, 4)] = "111110110"
K5[(1, 5)] = "11111110110"
K5[(1, 6)] = "1111111110000100"
K5[(1, 7)] = "1111111110000101"
K5[(1, 8)] = "1111111110000110"
K5[(1, 9)] = "1111111110000111"
K5[(1,10)] = "1111111110001000"

K5[(2, 1)] = "11100"
K5[(2, 2)] = "11111001"
K5[(2, 3)] = "1111110111"
K5[(2, 4)] = "111111110100"
K5[(2, 5)] = "1111111110001001"
K5[(2, 6)] = "1111111110001010"
K5[(2, 7)] = "1111111110001011"
K5[(2, 8)] = "1111111110001100"
K5[(2, 9)] = "1111111110001101"
K5[(2,10)] = "1111111110001110"

K5[(3, 1)] = "111010"
K5[(3, 2)] = "111110111"
K5[(3, 3)] = "111111110101"
K5[(3, 4)] = "1111111110001111"
K5[(3, 5)] = "1111111110010000"
K5[(3, 6)] = "1111111110010001"
K5[(3, 7)] = "1111111110010010"
K5[(3, 8)] = "1111111110010011"
K5[(3, 9)] = "1111111110010100"
K5[(3,10)] = "1111111110010101"

K5[(4, 1)] = "111011"
K5[(4, 2)] = "1111111000"
K5[(4, 3)] = "1111111110010110"
K5[(4, 4)] = "1111111110010111"
K5[(4, 5)] = "1111111110011000"
K5[(4, 6)] = "1111111110011001"
K5[(4, 7)] = "1111111110011010"
K5[(4, 8)] = "1111111110011011"
K5[(4, 9)] = "1111111110011100"
K5[(4,10)] = "1111111110011101"

K5[(5, 1)] = "1111010"
K5[(5, 2)] = "11111110111"
K5[(5, 3)] = "1111111110011110"
K5[(5, 4)] = "1111111110011111"
K5[(5, 5)] = "1111111110100000"
K5[(5, 6)] = "1111111110100001"
K5[(5, 7)] = "1111111110100010"
K5[(5, 8)] = "1111111110100011"
K5[(5, 9)] = "1111111110100100"
K5[(5,10)] = "1111111110100101"

K5[(6, 1)] = "1111011"
K5[(6, 2)] = "111111110110"
K5[(6, 3)] = "1111111110100110"
K5[(6, 4)] = "1111111110100111"
K5[(6, 5)] = "1111111110101000"
K5[(6, 6)] = "1111111110101001"
K5[(6, 7)] = "1111111110101010"
K5[(6, 8)] = "1111111110101011"
K5[(6, 9)] = "1111111110101100"
K5[(6,10)] = "1111111110101101"

K5[(7, 1)] = "11111010"
K5[(7, 2)] = "111111110111"
K5[(7, 3)] = "1111111110101110"
K5[(7, 4)] = "1111111110101111"
K5[(7, 5)] = "1111111110110000"
K5[(7, 6)] = "1111111110110001"
K5[(7, 7)] = "1111111110110010"
K5[(7, 8)] = "1111111110110011"
K5[(7, 9)] = "1111111110110100"
K5[(7,10)] = "1111111110110101"

K5[(8, 1)] = "111111000"
K5[(8, 2)] = "111111111000000"
K5[(8, 3)] = "1111111110110110"
K5[(8, 4)] = "1111111110110111"
K5[(8, 5)] = "1111111110111000"
K5[(8, 6)] = "1111111110111001"
K5[(8, 7)] = "1111111110111010"
K5[(8, 8)] = "1111111110111011"
K5[(8, 9)] = "1111111110111100"
K5[(8,10)] = "1111111110111101"

K5[(9, 1)] = "111111001"
K5[(9, 2)] = "1111111110111110"
K5[(9, 3)] = "1111111110111111"
K5[(9, 4)] = "1111111111000000"
K5[(9, 5)] = "1111111111000001"
K5[(9, 6)] = "1111111111000010"
K5[(9, 7)] = "1111111111000011"
K5[(9, 8)] = "1111111111000100"
K5[(9, 9)] = "1111111111000101"
K5[(9,10)] = "1111111111000110"

K5[(10, 1)] = "111111010"
K5[(10, 2)] = "1111111111000111"
K5[(10, 3)] = "1111111111001000"
K5[(10, 4)] = "1111111111001001"
K5[(10, 5)] = "1111111111001010"
K5[(10, 6)] = "1111111111001011"
K5[(10, 7)] = "1111111111001100"
K5[(10, 8)] = "1111111111001101"
K5[(10, 9)] = "1111111111001110"
K5[(10,10)] = "1111111111001111"

K5[(11, 1)] = "1111111001"
K5[(11, 2)] = "1111111111010000"
K5[(11, 3)] = "1111111111010001"
K5[(11, 4)] = "1111111111010010"
K5[(11, 5)] = "1111111111010011"
K5[(11, 6)] = "1111111111010100"
K5[(11, 7)] = "1111111111010101"
K5[(11, 8)] = "1111111111010110"
K5[(11, 9)] = "1111111111010111"
K5[(11,10)] = "1111111111011000"

K5[(12, 1)] = "1111111010"
K5[(12, 2)] = "1111111111011001"
K5[(12, 3)] = "1111111111011010"
K5[(12, 4)] = "1111111111011011"
K5[(12, 5)] = "1111111111011100"
K5[(12, 6)] = "1111111111011101"
K5[(12, 7)] = "1111111111011110"
K5[(12, 8)] = "1111111111011111"
K5[(12, 9)] = "1111111111100000"
K5[(12,10)] = "1111111111100001"

K5[(13, 1)] = "11111111000"
K5[(13, 2)] = "1111111111100010"
K5[(13, 3)] = "1111111111100011"
K5[(13, 4)] = "1111111111100100"
K5[(13, 5)] = "1111111111100101"
K5[(13, 6)] = "1111111111100110"
K5[(13, 7)] = "1111111111100111"
K5[(13, 8)] = "1111111111101000"
K5[(13, 9)] = "1111111111101001"
K5[(13,10)] = "1111111111101010"

K5[(14, 1)] = "1111111111101011"
K5[(14, 2)] = "1111111111101100"
K5[(14, 3)] = "1111111111101101"
K5[(14, 4)] = "1111111111101110"
K5[(14, 5)] = "1111111111101111"
K5[(14, 6)] = "1111111111110000"
K5[(14, 7)] = "1111111111110001"
K5[(14, 8)] = "1111111111110010"
K5[(14, 9)] = "1111111111110011"
K5[(14,10)] = "1111111111110100"

K5[(15, 0)] = "11111111001"
K5[(15, 1)] = "1111111111110101"
K5[(15, 2)] = "1111111111110110"
K5[(15, 3)] = "1111111111110111"
K5[(15, 4)] = "1111111111111000"
K5[(15, 5)] = "1111111111111001"
K5[(15, 6)] = "1111111111111010"
K5[(15, 7)] = "1111111111111011"
K5[(15, 8)] = "1111111111111100"
K5[(15, 9)] = "1111111111111101"
K5[(15,10)] = "1111111111111110"


reverse_K5 =  {"".join(val): key for key, val in K5.items()}
reverse_K3 =  {"".join([str(k) for k in val]): key for key, val in K3.items()}

# Memoized function
# Filters the tables and only searches in tables that start with code
# this will filter out most of the keys at first iterations
# the lookup doesn't need to use all items, as long as it finds a single one
def lookup_table(table):
    table_keys = list(table.keys())
    key_accum = []

    def find(table_keys, key_accum, partial_key):
        key_accum += [str(partial_key)]

        needle = "".join(key_accum)
        filtered_keys =  list(filter(lambda table_key: table_key.startswith(needle), table_keys))

        if(len(filtered_keys) > 1):
            table_keys = filtered_keys
            return False

        key_accum = []
        return table[filtered_keys[0]]

    return partial(find, table_keys, key_accum)

# Uses function above to return any K3 table value in int
# input: Stream
# output: int
def k3_lookup(stream):
    size = False
    find = lookup_table(reverse_K3)
    keys = []
    while(size is False):
        key = stream.get_bit()
        keys += [key]
        size = find(key)
    
    code = []
    while size > 0:
        bit = stream.get_bit()
        code += [bit]
        size = size - 1
    
    byte = bit_array_to_int(code, True)
    return byte

def k5_lookup(stream):
    k5_value = False
    find = lookup_table(reverse_K5)
    keys = []
    while(k5_value is False):
        key = stream.get_bit()
        keys += [key]
        k5_value = find(key)

    (zeroes_counter, size) = k5_value

    code = []
    while size > 0:
        bit = stream.get_bit()
        code += [bit]
        size = size - 1
    
    byte = bit_array_to_int(code, True)
    return (zeroes_counter,byte)


# zig-zag order
zigzag = np.zeros((8, 8))
zigzag[0] = [ 0,  1,  5,  6, 14, 15, 27, 28]
zigzag[1] = [ 2,  4,  7, 13, 16, 26, 29, 42]
zigzag[2] = [ 3,  8, 12, 17, 25, 30, 41, 43]
zigzag[3] = [ 9, 11, 18, 24, 31, 40, 44, 53]
zigzag[4] = [10, 19, 23, 32, 39, 45, 52, 54]
zigzag[5] = [20, 22, 33, 38, 46, 51, 55, 60]
zigzag[6] = [21, 34, 37, 47, 50, 56, 59, 61]
zigzag[7] = [35, 36, 48, 49, 57, 58, 62, 63]


Q = 1
#índice para ordenar valores de array 1D em zigzag
ind_O = zigzag.reshape((64),order='F').astype('int')
#índice para repor ordem original de array 1D em zigzag
ind_Z = np.argsort(ind_O)


def quality_factor(q):
    if(q <= 50):
        factor = 50.0 / q
    else:
        factor = 2.0 - (q * 2.0)/100.0
    return factor 

def test_zig_zag():
    #Exemplo:
    np.random.seed(1)
    D1=np.random.randint(-10,10,size=(8,8))
    print(D1)
    D1Flat=D1.flatten(order='F')
    D1zz=D1Flat[ind_Z]
    D2=D1zz[ind_O].reshape((8,8),order='F')

def test_lookup_table(code, table):
    find = lookup_table(table)

    value = False
    while(value is False):
        key = code.pop(0) #emitates a stream spitting out bytes
        value = find(key)
    print(value)
    return value

if __name__ == '__main__':  
    k3_11 = ["1","1","1","1","1","1","1","1","0"]
    k3_8 = ["1","1","1","1","1","0"]
    k3_1 = ["0","1","0"]

    assert(test_lookup_table(k3_11, reverse_K3) == 11)
    assert(test_lookup_table(k3_8, reverse_K3)  == 8)
    assert(test_lookup_table(k3_1, reverse_K3) == 1)


    k5_14_7 = list('1111111111110001')
    k5_15_10 = list('1111111111111110')
    k5_0_0 = list('1010')

    assert(test_lookup_table(k5_14_7, reverse_K5) == (14,7))
    assert(test_lookup_table(k5_15_10, reverse_K5) == (15,10))
    assert(test_lookup_table(k5_0_0, reverse_K5) == (0,0))